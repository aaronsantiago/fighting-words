<html>
<script src="scripts/netplay.js"></script>
<script src="scripts/scrabbleWords.js"></script>
<body></body>
<script>

  // some variables to control the overall game
  const gridSize = 20;
  const startingPositionOffset = 5;
  const playerHandCount = 8;
  const allowOffscreenPlacements = false;

  // some useful constants
    // (i'm a colemak main)
  const allLetters = "qwfpgjluyarstdhneiozxcvbkm";
  const weightedLettersList = 
  "aaaaeeeiiiooouudhndhnrrrssssllhttqwfpgjluyarstdhneiozxcvbkm";

  // variables
  let localPlayerId = 0;

  // utility functions
  function generateRandomLetters(count) {
    let letters = [];
    for(let i = 0; i < count; i++) {
      letters.push(weightedLettersList[Math.floor(Math.random() * weightedLettersList.length)]);
    }
    return letters;
  }

	class SimpleGame extends netplayjs.Game {
  constructor(canvas, players) {
    super();

    for (let player of players) {
      if (player.isLocal) {
        localPlayerId = player.id;
      }
    }

    // the board is ordered left to right, top to bottom like this:
    //  0  1  2  3
    //  4  5  6  7
    //  8  9 10 11
    // 12 13 14 15
    // etc.

    // calculate starting positions for players. we'll use this
    // when we generate the board.

    // multiply the y component by grid size to get the index of the starting location.
    let p1Pos = startingPositionOffset             + Math.floor((gridSize - 1)/2) * gridSize;
    let p2Pos = gridSize - startingPositionOffset  + Math.ceil((gridSize - 1)/2) * gridSize;

    // generate the board.
    this.board = [];
    // leave room for the stack at the bottom
    for(let i = 0; i < gridSize * (gridSize - 1); i++) {
      if (i == p1Pos) {
        this.board.push("a1");
      }
      else if (i == p2Pos) {
        this.board.push("a2");
      }
      else {
        this.board.push("");
      }
    }

    // generate the player letters
    this.p1Letters = generateRandomLetters(playerHandCount);
    this.p2Letters = generateRandomLetters(playerHandCount);

    this.p1Queue = "";
    this.p2Queue = "";

    this.p1LocationSelection = 0;
    this.p2LocationSelection = 0;

    // need this to only respond to keydowns
    this.p1LastPressed = {};
    this.p2LastPressed = {};

    this.winner = "0";

  }
  validatePlacement(processedWord, x, y, vertical, heldCounts, playerNum) {

    let playerNumFound = false;
    let requiredHeldLetters = {};
    for (let letter in heldCounts) {
      requiredHeldLetters[letter] = 0;
    }

    let placementIndices = [];
    for (let i = 0; i < processedWord.length; i++) {
      let pwl = processedWord[i];

      let tx = x;
      let ty = y;
      if (vertical) {
        ty = y + i;
      }
      else {
        tx = x + i;
      }
      placementIndices.push(tx + ty * gridSize);

      // check for off-screen placement
      if ((tx < 0 || tx >= gridSize) || (ty < 0 || ty >= gridSize)) {
        if (!allowOffscreenPlacements) {
          return null;
        }
      }


      let tile = this.board[tx + ty * gridSize];
      if (tile == null) tile = "";
      // only check for negative cases and return out if it is invalid
        // if this letter is on the board and it does not match, invalid
      if (tile == "") {
        // if the letter is missing on the board and we don't have it, invalid
        if (pwl[1] == "m") {
          return null;
        }
        requiredHeldLetters[pwl[0]] += 1;
        // if we don't have enough, invalid
        if (requiredHeldLetters[pwl[0]] > heldCounts[pwl[0]]) {
          return null;
        }
      }
      // if the slot is not empty and does not match, invalid
      else {
        if (tile[1] == playerNum) playerNumFound = true;
        if (tile[0] != pwl[0]) {
          return null;
        }
      }
    }
    
    if (playerNumFound) {
      // check if the words are valid
      let rowsToCheck = [y];
      let columnsToCheck = [x];
      if (vertical) {
        for (let r = 1; r < processedWord.length; r++) {
          rowsToCheck.push(y + r);
        }
      }
      else {
        for (let c = 1; c < processedWord.length; c++) {
          columnsToCheck.push(x + c);
        }
      }

      for (let ry of rowsToCheck) {
        let currentWord = "";
        let intersected = false;
        // |a|b| |a|b|B| 
        for (let rx = 0; rx < gridSize + 1; rx++) {
          let tileIndex = rx + ry * gridSize;
          let tile = this.board[tileIndex][0];
          
          // check intersection with current placement
          let placementIndex = placementIndices.indexOf(tileIndex);
          if (placementIndex >= 0) {
            intersected = true;
            tile = processedWord[placementIndex][0];
          }

          if (tile == null || tile == "" || rx >= gridSize) {
            // end case
            if(intersected) {
              // console.log("row: " + ry + "vertical: " + vertical);
              // console.log(currentWord);
              // console.log(currentWord.toUpperCase());
              // console.log(currentWord.toUpperCase() in scrabbleWords);
              // if (!(true) && currentWord.length > 1) {
              if (!(currentWord.toUpperCase() in scrabbleWords) && currentWord.length > 1) {
                return null;
              }
            }
            currentWord = "";
            intersected = false;
          }
          else {
            currentWord += tile;
          }
        }
      }
      
      for (let cx of columnsToCheck) {
        let currentWord = "";
        let intersected = false;
        // |a|b| |a|b|B| 
        for (let cy = 0; cy < gridSize; cy++) {
          let tileIndex = cx + cy * gridSize;
          let tile = this.board[tileIndex];
          if (tile == null) {
            tile = "";
          }
          else {
            tile = tile[0];
          }
          
          // check intersection with current placement
          let placementIndex = placementIndices.indexOf(tileIndex);
          if (placementIndex >= 0) {
            intersected = true;
            tile = processedWord[placementIndex][0];
          }

          if (tile == null || tile == "" || cy >= gridSize) {
            // end case
            if(intersected) {
              // console.log("col: " + cy + "vertical: " + vertical);
              // console.log(currentWord);
              // console.log(currentWord.toUpperCase());
              // console.log(currentWord.toUpperCase() in scrabbleWords);
              if (!(currentWord.toUpperCase() in scrabbleWords) && currentWord.length > 1) {
                return null;
              }
            }
            currentWord = "";
            intersected = false;
          }
          else {
            currentWord += tile;
          }
        }
      }


      let requiredLetters = [];
      for (let l in requiredHeldLetters) {
        for (let i = 0; i < requiredHeldLetters[l]; i++) {
          requiredLetters.push(l);
        }
      }

      return requiredLetters;
    }
  }

  findValidLocations(word, letters, playerNum) {
    let validPlacements = [];

    let processedWord = [];
    let firstMissingLetter = "";

    let playerFound = false;
    
    // let letterCountsInWord = {};
    let heldCounts = {};

    let checkedLetters = {};
    
    for (let l of letters) {
      if (!(l in heldCounts)) {
        heldCounts[l] = 1;
        // letterCountsInWord[l] = 0;
        checkedLetters[l] = 0;
      }
      else {
        heldCounts[l] += 1;
      }
    }
    let missingLetterLocations = [];
    for (let wl of word) {
      if (letters.indexOf(wl) >= 0) {
        processedWord.push(wl + "h");
      }
      else {
        if (firstMissingLetter == "") {
          firstMissingLetter = wl;
          missingLetterLocations.push(processedWord.length);
        }
        processedWord.push(wl + "m");
      }
    }
    for(let t = 0; t < this.board.length; t++) {
      let tile = this.board[t];

      // skip processing any spaces that don't have letters in them
      if (tile == "") continue;
      let x = t % gridSize;
      let y = Math.floor(t/gridSize);
      // if (firstMissingLetter == tile[0]) {
        // check all possible locations of missing letter
      for (let i = 0; i < processedWord.length; i++) {
        let usedLetters = this.validatePlacement(processedWord, x - i, y, false, heldCounts, playerNum);
        if (usedLetters != null) {
          validPlacements.push({x: x - i, y: y, vertical: false, usedLetters: usedLetters});
        }
        usedLetters = this.validatePlacement(processedWord, x, y - i, true, heldCounts, playerNum);
        if (usedLetters != null) {
          validPlacements.push({x: x, y: y - i, vertical: true, usedLetters: usedLetters});
        }
      }
      // }
    }
    return validPlacements;
  }

  // The tick function takes a map of Player -> Input and
  // simulates the game forward. Think of it like making
  // a local multiplayer game with multiple controllers.
  tick(playerInputs) {
    if (this.winner != "0") {
      return;
    }
    for (const [player, input] of playerInputs.entries()) {
      // // Generate player velocity from input keys.
      // const vel = {
      //   x:
      //     (input.pressed.ArrowLeft ? -1 : 0) +
      //     (input.pressed.ArrowRight ? 1 : 0),
      //   y:
      //     (input.pressed.ArrowDown ? -1 : 0) +
      //     (input.pressed.ArrowUp ? 1 : 0),
      // };

      // // Apply the velocity to the appropriate player.
      if (player.getID() == 0) {
        for (let letter of allLetters) {
          if ((letter in input.pressed) && !(letter in this.p1LastPressed) ) {
            this.p1Queue += letter;
            this.p1LocationSelection = 0;
          }
        }
        if(input.pressed.Shift && !("Shift" in this.p1LastPressed)) {
          this.p1LocationSelection += 1;
        }
        if(input.pressed.Enter && !("Enter" in this.p1LastPressed)) {
          let validLocations = this.findValidLocations(this.p1Queue, this.p1Letters, "1");

          if (validLocations.length > 0) {
            //clear off player 1 tag from existing letters
            for (let ti = 0; ti < this.board.length; ti++) {
              if(this.board[ti][1] == "1") this.board[ti] = this.board[ti][0];
            }

            let validLocation = validLocations[this.p1LocationSelection % validLocations.length];
            for(let z = 0; z < this.p1Queue.length; z++) {

              let tileX = validLocation.x;
              let tileY = validLocation.y;

              if (validLocation.vertical) {
                tileY = validLocation.y + z;
              }
              else {
                tileX = validLocation.x + z;
              }
              for (let wx = tileX - 1; wx < tileX + 2; wx++) {
                if (this.board[wx + tileY * gridSize][1] == "2") {
                  this.winner = "1";
                }
              }
              for (let wy = tileY - 1; wy < tileY + 2; wy++) {
                if (this.board[tileX + wy * gridSize][1] == "2") {
                  this.winner = "1";
                }
              }

              this.board[tileX + tileY * gridSize] = this.p1Queue[z] + "1";
            }
            this.p1Queue = "";
            
            let newLetters = [];
            for (let letter of this.p1Letters) {
              let letterIndex = validLocation.usedLetters.indexOf(letter);
              if (letterIndex >= 0) {
                validLocation.usedLetters.splice(letterIndex,1);
              }
              else {
                newLetters.push(letter);
              }
            }
            this.p1Letters = newLetters.concat(generateRandomLetters(playerHandCount - newLetters.length));
          }
        }
        if(input.pressed.Backspace) {
          this.p1Queue = "";
          this.p1LocationSelection = 0;
        }
        this.p1LastPressed = Object.assign({},input.pressed);
      } else if (player.getID() == 1) {
        for (let letter of allLetters) {
          if ((letter in input.pressed) && !(letter in this.p2LastPressed) ) {
            this.p2Queue += letter;
            this.p2LocationSelection = 0;
          }
        }
        if(input.pressed.Shift && !("Shift" in this.p2LastPressed)) {
          this.p2LocationSelection += 1;
        }
        if(input.pressed.Enter && !("Enter" in this.p2LastPressed)) {
          let validLocations = this.findValidLocations(this.p2Queue, this.p2Letters, "2");

          if (validLocations.length > 0) {
            //clear off player 1 tag from existing letters
            for (let ti = 0; ti < this.board.length; ti++) {
              if(this.board[ti][1] == "2") this.board[ti] = this.board[ti][0];
            }

            let validLocation = validLocations[this.p2LocationSelection % validLocations.length];
            for(let z = 0; z < this.p2Queue.length; z++) {

              let tileX = validLocation.x;
              let tileY = validLocation.y;

              if (validLocation.vertical) {
                tileY = validLocation.y + z;
              }
              else {
                tileX = validLocation.x + z;
              }

              for (let wx = tileX - 1; wx < tileX + 2; wx++) {
                if (this.board[wx + tileY * gridSize][1] == "1") {
                  this.winner = "2";
                }
              }
              for (let wy = tileY - 1; wy < tileY + 2; wy++) {
                if (this.board[tileX + wy * gridSize][1] == "1") {
                  this.winner = "2";
                }
              }

              this.board[tileX + tileY * gridSize] = this.p2Queue[z] + "2";
            }
            this.p2Queue = "";

            let newLetters = [];
            for (let letter of this.p2Letters) {
              let letterIndex = validLocation.usedLetters.indexOf(letter);
              if (letterIndex >= 0) {
                validLocation.usedLetters.splice(letterIndex,1);
              }
              else {
                newLetters.push(letter);
              }
            }
            this.p2Letters = newLetters.concat(generateRandomLetters(playerHandCount - newLetters.length));
          }
        }
        if(input.pressed.Backspace) {
            this.p2LocationSelection = 0;
          this.p2Queue = "";
        }
        this.p2LastPressed = Object.assign({},input.pressed);
      }

    }
  }

  draw(canvas) {
    const ctx = canvas.getContext("2d");

    // Fill with black.
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    let smallerDimension = Math.min(canvas.width, canvas.height);
    let tileSize = smallerDimension/gridSize;
    let xBoardStart = canvas.width/2 - smallerDimension/2;
    let yBoardStart = canvas.height/2 - smallerDimension/2;
    for(let x = 0; x < gridSize; x++) {
      for(let y = 0; y < gridSize - 1; y++) {
        let tile = this.board[x + y * gridSize];

        let tileStartX = xBoardStart + x * tileSize;
        let tileStartY = yBoardStart + y * tileSize
        ctx.strokeStyle = "darkgrey";
        ctx.strokeRect(tileStartX, tileStartY, tileSize, tileSize);

        if (tile != "") {
          ctx.font = '25px Arial';
          ctx.textBaseline = 'middle'; 
          ctx.textAlign = 'center'; 

          if (tile[1] == "1") {
            ctx.fillStyle = 'red';
          }
          else if (tile[1] == "2") {
            ctx.fillStyle = 'lightblue';
          }
          else {
            ctx.fillStyle = 'grey';
          }

          ctx.fillText(tile[0], tileStartX + tileSize/2, tileStartY + tileSize/2);
        }
      }
    }
    if (this.winner != "0") {
      ctx.font = '25px Arial';
      ctx.textBaseline = 'middle'; 
      ctx.textAlign = 'center'; 
      ctx.fillStyle = 'white';
      let winText = "player " + this.winner + " wins!";
      for(let x = 0; x < winText.length; x++) {

        let tileStartX = xBoardStart + x * tileSize;
        let tileStartY = yBoardStart + (gridSize - 1) * tileSize
        
        ctx.fillText(winText[x], tileStartX + tileSize/2, tileStartY + tileSize/2);
      }
    }
    else {
      let charsToDraw = this.p1Letters;
      let currentQueue = this.p1Queue;
      let locationSelection = this.p1LocationSelection;
      let playerNum = "1";
      if (localPlayerId == 1) { 
        charsToDraw = this.p2Letters;
        currentQueue = this.p2Queue;
        locationSelection = this.p2LocationSelection;
        playerNum = "2";
      }

      ctx.font = '25px Arial';
      ctx.textBaseline = 'middle'; 
      ctx.textAlign = 'center'; 
      ctx.fillStyle = 'white';
      for(let x = 0; x < charsToDraw.length; x++) {

        let tileStartX = xBoardStart + x * tileSize;
        let tileStartY = yBoardStart + (gridSize - 1) * tileSize
        
        ctx.fillText(charsToDraw[x], tileStartX + tileSize/2, tileStartY + tileSize/2);
      }
      for(let x = 0; x < currentQueue.length; x++) {

        let tileStartX = xBoardStart + gridSize * tileSize - (x + 1) * tileSize;
        let tileStartY = yBoardStart + (gridSize - 1) * tileSize
        
        ctx.fillText(currentQueue[currentQueue.length - x - 1], tileStartX + tileSize/2, tileStartY + tileSize/2);
      }

      let validLocations = this.findValidLocations(currentQueue, charsToDraw, playerNum);

      if (validLocations.length > 0) {
        let validLocation = validLocations[locationSelection % validLocations.length];
        for(let z = 0; z < currentQueue.length; z++) {

          let tileStartX = xBoardStart + validLocation.x * tileSize;
          let tileStartY = yBoardStart + validLocation.y * tileSize;

          if (validLocation.vertical) {
            tileStartY = yBoardStart + (validLocation.y + z) * tileSize;
          }
          else {
            tileStartX = xBoardStart + (validLocation.x + z) * tileSize;
          }

          ctx.fillText(currentQueue[z], tileStartX + tileSize/2, tileStartY + tileSize/2);
        }
      }
    }
    // // Draw squares for the players.
    // ctx.fillStyle = "red";
    // ctx.fillRect(this.aPos.x - 5, this.aPos.y - 5, 10, 10);
    // ctx.fillStyle = "blue";
    // ctx.fillRect(this.bPos.x - 5, this.bPos.y - 5, 10, 10);
  }
}

SimpleGame.timestep = 1000 / 60; // Our game runs at 60 FPS
SimpleGame.canvasSize = { width: 600, height: 600 };


window.addEventListener('resize', function() {
// SimpleGame.canvasSize = { width: window.innerWidth, height: window.height };

}, true);
// Because our game can be easily rewound, we will use Rollback netcode
// If your game cannot be rewound, you should use LockstepWrapper instead.
let game = new netplayjs.RollbackWrapper(SimpleGame);
game.start();
</script>
</html>